# Class: App::webcritic::Critic::Policy::Site::Structure
#   Site's policy: build site structure.
# Extends:
#   App::webcritic::Critic::Policy::Site::Interface
#   App::webcritic::Critic::Log::AbstractLogger
package App::webcritic::Critic::Policy::Site::Structure;
use Pony::Object qw/App::webcritic::Critic::Policy::Site::Interface
                    App::webcritic::Critic::Log::AbstractLogger/;
use App::webcritic::Critic::Site::Page;
use App::webcritic::Critic::Site::Page::Link;
use Pony::Object::Throwable;
use Encode;
  
  protected 'name';
  protected 'site';
  protected 'options';
  protected 'indexed' => {};
  protected 'childs_by_url' => {};
  
  # Var: status
  # | Inspect status.
  # |   0 - all fine
  # |   1 - something wrong
  # |   2 - too bad
  protected 'status';
  
  # Method: init
  #   Constructor
  sub init : Public
    {
      my $this = shift;
      $this->options = shift || {};
    }
  
  # Method: set_name
  #   setter for name
  #
  # Parameters:
  #   $this->name - Str
  sub set_name : Public
    {
      my $this = shift;
      $this->name = shift;
    }
  
  # Method: set_site
  #   setter for site property
  #
  # Parameters:
  #   $this->site - App::webcritic::Critic::Site
  sub set_site : Public
    {
      my $this = shift;
      $this->site = shift;
      $this->set_log_level($this->site->get_log_level);
      $this->log_info('Start NotFound policy');
    }
  
  # Method: get_status
  #   getter for status
  #
  # Returns:
  #   $this->status - Int - result
  sub get_status : Public
    {
      my $this = shift;
      return $this->status;
    }
  
  # Method: inspect
  #   inspect site
  sub inspect : Public
    {
      my $this = shift;
      my %struct;
      $this->status = 0;
      
      my %childs;
      my @queue = ($this->site->get_first_page->get_url);
      
      while (my $url = shift @queue) {
        my $page = $this->site->get_page_by_url($url);
        
        next if defined $this->indexed->{$url} && $this->indexed->{$url} eq 'page';
        next unless defined $page;
        next if not defined $page->get_content;
        next if $page->get_content->get_content eq '';
        
        $this->indexed->{$url} = 'page';
        
        my @links =
          grep { $this->indexed->{$_} = 'link' } # sorry for hack
          grep {not exists $this->indexed->{$_}}
          map {$_->get_url} @{$page->get_link_list};
        
        push @queue, @links;
        $childs{$url} = \@links;
      }
      $this->childs_by_url = \%childs;
      
      #
      $this->indexed = {}; # flush indexed
      my $tree = {
        url => $this->site->get_first_page->get_url,
        title => $this->site->get_first_page->get_content->get_title,
        childs => $this->get_tree($this->site->get_first_page, 1)
      };
      
      # Render if demained
      if (exists $this->options->{output} && exists $this->options->{format}) {
        $this->render($tree);
      }
      
    }
  
  # Method: render
  #   render site tree
  #
  # Parameters:
  #   $tree - HashRef
  sub render : Public
    {
      my $this = shift;
      my $tree = shift;
      
      open(my $fh, '>utf8', $this->options->{output})
        or throw Pony::Object::Throwable(q{Can't write into }.$this->options->{output});
      
      if ($this->options->{format} eq 'html') {
        print $fh $this->render_html($tree);
      }
      
      close $fh;
    }
  
  # Method: render_html
  #   render site tree as html file
  #
  # Parameters:
  #   $tree - HashRef
  #
  # Returns:
  #   Str
  sub render_html : Public
    {
      my $this = shift;
      my $tree = shift;
      
      my $html = sprintf q{
          <html>
            <head>
              <meta charset="utf-8">
              <title>Website structure for %s (%s)</title>
            </head>
            <body>
              %s
              <small>Generated by <a href="https://github.com/h15/app-webcritic">WebCritic</a></small>
            </body>
          </html>
        },
        $tree->{title},
        $tree->{url},
        $this->render_html_list($tree);
      
      return $html;
    }
  
  sub render_html_list : Public
    {
      my $this = shift;
      my $tree = shift;
      
      my $html = sprintf qq{<a href="\%s">\%s</a>\n}, $tree->{url}, ($tree->{title} || 'titleless');
      $html .= '<ul>';
      $html .= sprintf(qq{<li>\%s</li>\n}, $this->render_html_list($_)) for @{$tree->{childs}};
      $html .= '</ul>';
      
      return $html;
    }
  
  # Method: get_tree
  #   get tree
  #
  # Parameters:
  #   $page - App::webcritic::Critic::Site::Page
  #   $depth - Int - iteration depth (1 - BFS, 100000000000000000 - DFS)
  #
  # Returns:
  #   ArrayRef
  sub get_tree : Public
    {
      my $this = shift;
      my ($root_page, $depth) = @_;
      my @pages;
      
      # Create child list
      for my $url (@{ $this->childs_by_url->{$root_page->get_url} }) {
        my $page = $this->site->get_page_by_url($url);
        
        next if $this->indexed->{$url};
        next if not defined $page;
        next if not defined $page->get_content;
        next if $page->get_content->get_content eq '';
        
        $this->indexed->{$url}++;
        
        push @pages, {
          title => $page->get_content->get_title,
          url => $page->get_url,
          childs => sub { $this->get_tree($page, @_) }
        };
      }
      
      # Looking for childs' childs
      for my $page (@pages) {
        $page->{childs} = $depth > 0 ? $page->{childs}->($depth - 1) : [];
      }
      
      return \@pages;
    }
  
1;

__END__

=pod

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2013, Georgy Bazhukov.

This program is free software, you can redistribute it and/or modify it under
the terms of the Artistic License version 2.0.

=cut
